\chapter{Estado del Arte \label{estado}}
Un algoritmo de reconstrucción se compone de varios sub-procesos, que en conjunto permiten reconstruir la energía y posición de una o más partículas detectadas. Si bien existen varias posibilidades en el proceso de reconstrucción, tales como la reconstrucción del ángulo de incidencia, la reconstrucción de trayectoria~\cite{speer2006track}, las principales tareas que interesan en este trabajo son: el agrupamiento de los datos, la identificación de máximos en los clusters, la identificación y separación (cuando es posible) de partículas solapadas y la reconstrucción de la posición y energía de cada una de estas partículas.\\
A continuación se analizarán cada una de estas tareas por separado.
\section {Clustering de partículas}
La entrada al algoritmo es la medición de cada uno de los lectores del sistema. La estructura de esta entrada depende de la configuración del sistema de lectura, este puede ser capaz de medir la energía (o fotoelectrones) depositada en cada celda o sólo medir una proyección en cada eje de la energía depositada (como en el caso del preshower). La entrada depende del sistema de lectura, pero comúnmente corresponde a un conjunto de valores de energía o fotoelectrones que deben ser agrupados de manera de representar partículas incidentes. Las partículas incidentes usualmente depositan su energía en varias celdas o cristales del calorímetro. La finalidad de los algoritmos presentados aquí es agrupar estas celdas. El algoritmo debe también eliminar posibles fuentes de ruido en las lecturas en caso de ser posible. El ruido en los calorímetros viene de dos fuentes principales. Primero, ruido es introducido por distintos procesos en la electrónica de lectura. Segundo, existe ruido conocido como de apilamiento (\emph{pile-up}). Este tipo de ruido proviene de interacciones extras que ocurren al mismo tiempo que la partícula atraviesa el detector.

Varios métodos han sido propuestos en la literatura para formar los clusters en calorímetros basados en cristales. Entre los algoritmos propuestos se pueden encontrar métodos de construcción incremental de los clusters que funcionan muy bien en la práctica, también es posible encontrar algoritmos más avanzados que utilizan métodos probabilísticos para construir los clusters. 

En lo que continua analizaremos algunos de los algoritmos más utilizados en el trabajo de clustering en detectores con geometrías relativamente similar al detector preshower. 

\subsection{Ventana deslizante}
Este algoritmo es propuesto por el experimento ATLAS y es utilizado en el proceso de reconstrucción del calorímetro electromagnético y el calorímetro hadrónico~\cite{lampl2008calorimeter}. Los clusters pueden utilizar información combinada de ambos calorímetros, esto es útil para reconstruir jets e identificación de leptones Tau o utilizar solo la información del calorímetro electromagnético, útil para la reconstrucción de electrones y fotones.  

El detector calorímetro en atlas se compone tanto de secciones longitudinales como secciones transversales, las secciones longitudinales se extienden en el espacio $\eta - \sigma$, y existen cuatro secciones transversales en el caso del calorímetro electromagnético: \emph{middle}, \emph{strips}, \emph{pre-sampler} y \emph{back}.

El algoritmo se compone de tres pasos principales: construcción de torres, búsqueda de pre-clusters y llenado de clusters. 

\subsubsection{Construcción de torres}
El espacio longitudinal $\eta-\sigma$ es segmentado en $N_{\eta}\times N_{\phi}$ celdas de tamaño $\Delta \eta \times \Delta \phi$ formando torres transversales de celdas donde la energía depositada es sumada. Los valores $N_{\eta}$ y $N_{\phi}$ son definidos como parámetros del algoritmo y deben ser seleccionados de antemano. Si existen celdas que corresponden a más de una torre, entonces la energía de las celdas es repartida en en proporción al área de la celda en cada torre.

\subsubsection{Búsqueda de pre-clusters}
 Se define una ventana de tamaño fijo $N^{window}_{\eta} \times N^{window}_{\phi}$ en unidades del tamaño de torre $\Delta \eta \times \Delta \phi$. La ventana es movida a lo largo de las torres construidas y pre-clusters son formados en los máximos locales de energía acumulada en la torre (definida como la suma de energías en todas las celdas que forman parte de la torre) que, además, superen un umbral $E_T^{thresh}$.
 
 La posición en el eje $\eta-\phi$ de los pre-clusters obtenidos en este paso es calculada utilizando el centro de masa con pesos iguales a la energía en cada una de las celdas incluidas en las torres. Es posible también definir tamaños menores para las ventanas utilizadas al calcular la posición, es decir utilizar $N^{pos}_{\eta} \times N^{pos}_{\phi}$, esto con la finalidad de minimizar el ruido introducido en el calculo de posición.
 
 Finalmente, este paso termina removiendo los clusters duplicados. Estos se definen como dos pre-clusters que tengan posiciones centrales dentro de $\Delta \eta_{dupl} \times \Delta \phi_{dupl}$. Sólo el pre-clusters con mayor cantidad de energía integrada es conservado.
 
\subsubsection{Llenado de clusters}

En el caso de estar trabajando en la formación de clusters combinados con información conjunta del calorímetro hadrónico y electromagnético, los cluster corresponden a los pre-clusters formados en el paso anterior. Para el caso de la construcción de clusters electromagnéticos, se definen diferentes tamaños de clusters para cada una de las capas del calorímetro, esto debido a que el campo electromagnético en el detector afecta de manera diferente a las partículas que pasan por el calorímetro en diferentes capas de este. Los nuevos cluster son construidos basándose en las posiciones calculadas para los pre-clusters. Además se pueden definir clusters de distintos tamaños dependiendo de la partícula hipotetizada. Nose ahondará mucho en esto último debido a que es muy específico al funcionamiento del detector calorímetro de ATLAS.

Este algoritmo es utilizado en el detector atlas para la reconstrucción de electrones y fotones~\cite{aad2012electron,atlas4calorimeter} y la reconstrucción de leptones Tau~\cite{kalinowski2009tau} (aunque en versiones actuales del algoritmo esto se cambió a clustering topológico).


%El algoritmo de ventana deslizante que se basa en sumar la energ\'ia (n\'otese que no necesariamente se trata de energ\'ia, puede ser conteo de foto-electrones u otra medida, de aqu\'i en adelante se utilizar\'a energ\'ia para simplificar la explicaci\'on) en celdas dentro de un rect\'angulo de tama\~no fijo. La posici\'on central del rect\'angulo es seleccionada de manera de maximizar la cantidad de energ\'ia contenida. Este algoritmo es utilizado en el detector ATLAS para la reconstrucci\'on de lluvias electromagn\'eticas~\cite{lampl2008calorimeter}~\cite{atlas4calorimeter}.

\subsection{Cluster topológico}

Otro método de clustering utilizado en el experimento ATLAS es el cluster topológico~\cite{lampl2008calorimeter,atlas2016topological}. Este algoritmo permite construir clusters de tamaño variable, a diferencia del algoritmo anterior con el que sólo se podían construir clusters de tamaño fijo. El algoritmo consiste de tres pasos principales: búsqueda de semillas, búsqueda de vecinos, construcción de clusters.
\subsubsection{Búsqueda de semillas}
El algoritmo comienza con la búsqueda de semillas para construir los clusters. Se identifican las celdas con un valor señal a ruido mayor a un umbral $t_{seed}$ definido de antemano. El valor de señal se define como el valor absoluto de la energía en la celda y otro valor equivalente, mientras que el ruido corresponde al valor esperado del ruido en base a consideraciones electrónicas y físicas. Cada celda seleccionada en este paso corresponde a un proto-cluster.
\subsubsection{Búsqueda de vecinos}
La lista de semillas es ordenada en orden descendente basándose en el valor de la razón señal a ruido. Entonces, por cada semilla en orden se consideran las celdas vecinas que superen un umbral $t_{cell}$. Si el vecino no esta en la lista de utilizados y supera el umbral entonces es agregado a un proto-cluster correspondiente a la semilla. Si la celda es adyacente también a otro proto-cluster entonces ambos son combinados. Si la celda agregada además supera un umbral $t_{neighbor}$ entonces la celda es utilizada como semilla para expandir el cluster. Esto asegura que las colas de las lluvias electromagnéticas no sean descartadas pero al mismo tiempo asegura que no se agregue ruido electrónico y de apilamiento. El proceso continua hasta procesar todas las semillas de la lista original, continuando luego con las semillas agregadas por los vecinos en el paso anterior. Esto continua hasta que no quedan más semillas. 
\subsubsection{Construcción de clusters}
Como paso final, los proto-clusters que quedan del paso anterior (algunos fueron combinados) son ordenados de mayor a menor (respecto a la energía u otro valor equivalente) y convertidos en clusters. Adicionalmente se pueden eliminar los que tengan energía total $E_t$ menor a un umbral $t_E$, con la finalidad de evitar clusters construidos de ruido.

Notar que es posible que los clusters obtenidos con el algoritmo de clustering topológico correspondan a más de una partícula incidente, debido al solapamiento de lluvias (para el clustering por ventana deslizante se asume que cada cluster de tamaño fijo corresponde a sólo una lluvia). Por lo anterior, es necesario agregar un paso de división de clusters, esto se tratará en la sección~\ref{solapamiento}. 

El algoritmo de cluster topológico ha sido utilizado extendidamente en la reconstrucción de jets y MTE (\emph{missing transverse momentum}) en los calorímetros electromagnético y hadrónico de ATLAS~\cite{pinfold2012evaluation,barillari2008local,cojocaru2004hadronic}, mostrando una gran eficiencia en la reconstrucción~\cite{atlas2016topological}.

\subsection{Fuzzy c-means}
Otro método exitosamente aplicado en la literatura es el algoritmo de clustering fuzzy c-means. K-means es una muy popular técnica de clustering que aprende de manera no supervisada a encontrar K clusters en los datos. Su uso es muy extendido en la minería de datos y se extiende por las mas variadas disciplinas. Para el trabajo de reconstrucción de partículas en detectores calorímetros, esta técnica (y en general cualquier técnica de clustering duro) no es adecuada ya que asigna cada dato a un sólo cluster, lo que no permite lluvias solapadas, que como ya se vio son muy comunes. Los métodos fuzzy, en cambio, permiten que cada punto pertenezca en menor o mayor grado a diferentes clusters. Estos métodos combinan los algoritmos de clustering básicos con la teoría fuzzy [FUZZY] que permite agregar conceptos de imprecisión e incerteza a los métodos duros. El algoritmo fuzzy c-means, en específico, es una versión fuzzy del algoritmo K-means. Existen estudios de la aplicación de este algoritmo para reconstrucción de partículas en calorímetros~\cite{FUZZY,PRESHOWER}, sin embargo, al conocimiento de este autor no hay aplicaciones reales (en detectores) de este algoritmo.

En ~\cite{FUZZY} el algoritmo fuzzy c-means y una extensión de este, el algoritmo dynamic fuzzy c-means, es aplicado para la reconstrucción en datos simulados de un detector calorímetro de muestreo. En este trabajo se demuestra la utilidad de los algoritmos fuzzy en la tarea de reconstrucción debido a la capacidad de estos métodos de manejar las lluvias solapadas automáticamente. 

Fuzzy c-means comienza con un conjunto de datos $X = (x_1, x_2, ..., x_N)$ con $x_i \in \mathbb{R}^d$, para estos datos busca el conjunto de clusters con centros $V = (v_1, v_2, ..., v_C)$ con $v_i \in \mathbb{R}^d$ que minimicen la función de costo 
\begin{equation}
J_m (U,V;X) = \sum_{k=1}^N \sum_{i=1}^C (u_{ik})^m||x_k - v_i||^2, \nonumber
\end{equation}
donde $U$ consiste de los valores $u_{ik}$ que corresponden a los grados de pertenencia de el punto $k$ al cluster $i$, $||x|| = \sqrt{x^Tx}$ es la norma de producto interno y el valor $m\in[1,\infty[$ (factor fuzzy) define el grado de fucificación del algoritmo, donde $m$ cercano a $1$ corresponde a un simple k-means. Imponiendo restricciones 
\begin{align}
\sum_{k=1}^N u_{ik} > 0, i \in \{1,...,C\} \nonumber \\
\sum_{i=1}^C u_{ik} = 1, k \in \{1,...,N\}. \nonumber
\end{align}	
Es posible resolver el problema iterando el siguiente algoritmo
\begin{equation}
u_{ik} = \bigg[\sum_{j=1}^C\bigg(\frac{D_{ik}}{D_{jk}}\bigg)^{\frac{2}{m-1}}\bigg]^{-1}, \nonumber
\end{equation}
con $D_{ik} = ||x_k - v_i|| > 0$ para todo $i$ y $k$. Y
\begin{equation}
v_i = \frac{\sum_{k=1}^n(u_{ik})^m x_k}{\sum_{k=1}^n(u_{ik})^m}. \nonumber
\end{equation}
El algoritmo procede alternando las estimaciones de $V$ y $U$ hasta alcanzar un número definido de iteraciones o alcanzar un umbral de error $\epsilon$ definido de ante mano.



